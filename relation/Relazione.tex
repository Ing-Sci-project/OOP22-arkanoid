\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage[italian]{babel}
\usepackage{appendix}
\usepackage[italian]{cleveref}

\title{RELAZIONE PROGETTO DI PROGRAMMAZIONE AD OGGETTI}
\author{Margherita Balzoni, Chiara Castiglioni, Edoardo Desiderio, \\Virginia Foschi, Simone Ruggeri}
\date{Febbraio 2023}

\begin{document}
\maketitle
\titlepage
\tableofcontents
\newpage

\chapter{Analisi}
Il seguente capitolo contine l'analisi dei requisiti e del problema, ovvero fornisce una descrizione del dominio applicativo e delle funzionalità offerte dall'applicazione.
\section{Requisiti}
Il progetto, commissionato dall'Università di Bologna\footnote{\url{https://www.unibo.it/it}}, si pone come obbiettivo la realizzazione di un videogioco del genere Arcade, di nome Arkanoid\footnote{\url{https://it.wikipedia.org/wiki/Arkanoid}}.\\L'obbiettivo del gioco è quello di superare i tre round per ogni livello di difficoltà cercando di totalizzare un punteggio elevato, abbattendo un certo numero di mattoncini colorati colpendoli con una sfera.
\\
\subsection*{Requisiti funzionali}
\begin{itemize}
    \item Menù principale che all'avvio del software permette di scegliere il livello in base alla difficoltà e visionare la classifica.
    \item L’applicazione implementa la fisica della palla e ne gestisce il rimbalzo con i bordi dell’arena, con il pad e con i mattoncini.
    \item Area di gioco composta da un certo numero di mattoncini che cambiano disposizione ad ogni livello.
    \item Gestione dei parametri del giocatore, in particolare vita (che diminuisce ogni volta che la pallina esce dall'arena di gioco) e il punteggio.
    \item Organizzazione del gioco a livelli, ciascuno composto da 3 round ciascuno
    \item Creazione di differenti bonus o malus
    \item Avanzamento del gioco con difficoltà incrementale (quantità di mattoncini aumentata per ogni round)
    \item Realizzazione e aggiornamento di una classifica basata sul punteggio del giocatore
          \subsection*{Requisiti non funzionali}
    \item Fluidità del movimento degli oggetti
    \item Grafica user-friendly
\end{itemize}
\section{Analisi e modello del dominio}
Il gioco è strutturato a livelli di difficoltà crescente, ognuno dei quali presenta una diversa disposizione composta da tre diverse tipologie di mattoncini. Ogni livello è composto da tre round dove vi è sempre più un numero crescente di mattoncini.
Il livello contiene anche informazioni riguardanti il punteggio, il quale incrementa man mano che i mattoncini vengono distrutti e la vita del giocatore.
\\Le vite stabiliscono il numero di tentativi che l'utente ha per superare il livello al termine delle quali il giocatore potrà segliere se salvare il proprio punteggio, tornare alla schermata di gioco oppure uscira dall'applicazione, le stesse scelte saranno disponibili anche in caso di vittoria.
\\Il giocatore ha a disposizione un pad che si può muovere solo orrizzontalmente con il quale potrà far rimbalzare la sfera contro i mattoncini.
Le tre tipologie di mattoncini sono:
\begin{itemize}
    \item NormalBrick: mattoncini normali che se colpiti una volta dalla palla vengono distrutti.
    \item HardBrick: mattoncini che devono essere colpiti due volte per essere distrutti.
    \item Obstacle: mattoncini indistruttibili.
\end{itemize}
Ulteriori dettagli circa le entità presenti possono essere consultati attraverso la \Cref{images:analysis} inserita di seguito.
\begin{figure}[H]
    \centering{}
    \includegraphics[scale=0.8]{images/analysis.png}
    \caption{Schema UML dell'analisi del problema, con rappresentate le entità principali ed i rapporti fra loro.}
    \label{images:analysis}
\end{figure}
\chapter{Design}
\section{Architettura}
Si è optato per un pattern architetturale ispirato a un MVC(Model , View, Controller) in cui ci siamo impegnati il più
possibile a mantenere separati gli aspetti logici, di controllo e di grafica. Tuttavia non ne rispetta tutti i principi poiché nella classe GameEngine ci siamo
serviti di una funzionalità di una libreria grafica (SwingWorker).
\\La nostra strategia ha comunque il vantaggio che qualora fosse necessario cambiare l'interfaccia grafica
questo non causerebbe modifiche nelle classi di Model e Controller.
\begin{figure}[H]
    \centering{}
    \includegraphics[scale=0.5]{images/MVC.png}
    \caption{Schema UML del pattern.}
    \label{images:MVC}
\end{figure}
Il pattern prevede comunque la suddivisione dei compiti in 3 parti:
\begin{itemize}
    \item Model gestisce i dati, la logica e le regole dell'applicazione.
    \item View responsabile della visualizzazione del dominio applicativo e dell'interazione con l'utente.
    \item Controller è l'elemento che si interporre tra il Model e la View.
\end{itemize}
Il Model è composto da varie classi e interfaccie che rappresentano i principali elementi applicativi (Level, Round, MovingObject, Brick, Pad, Surprise, SizeCalculation).
Di seguito nella \Cref{images:Model} seguente si può vedere una rappresentazione generale del Model.
\begin{figure}[H]
    \centering{}
    \includegraphics[scale=0.7]{images/Model.png}
    \caption{Schema UML del Model.}
    \label{images:Model}
\end{figure}
La View è gestita principalmente da un'interfaccia, UIController, che dirige tutti i vari JPanel (LeaderboardView, GameView, CommandsView, StartMenu) ed è colei
che comunica con il Controller dell'applicazione.
Vi è anche una classe astratta (AbstractView) che viene estesa dai vari menù di gioco (GameOver, PauseMenu e Victory) i quali utilizzano la classe CustomBtn
creata con lo scopo di avere i bottoni nei vari menù tutti con le stesse caratteristiche. Le principali dipendenze possono essere viste di seguito nella figura \Cref{images:View}.
\begin{figure}[H]
    \centering{}
    \includegraphics[scale=0.5]{images/View.png}
    \caption{Schema UML della View.}
    \label{images:View}
\end{figure}
Il Controller è costituito da una sola interfaccia che comunica con il Model e con la View ma anche con la classe GameEngine, il motore dell'applicazione.
\\Di seguito nella \Cref{images:Controller} l'UML del Controller.
\begin{figure}[H]
    \centering{}
    \includegraphics[scale=0.4]{images/Controller.png}
    \caption{Schema UML della View.}
    \label{images:Controller}
\end{figure}

\section{Desing dettagliato}
\textbf{Ruggeri Simone}\\
Le parti di lavoro da me svolte hanno riguardato: la progettazione della struttura dei vari livelli,
l'impostazione del primo livello con i suoi 3 round, il controllo se il giocatore manca la pallina oppure se finisce il round, lo sviluppo di
alcuni metodi per i bonus, la parte di grafica che riguarda la pausa, il game over e la vittoria.\\\\
\textbf{Livelli}\\
Il gioco è suddiviso in tre livelli. Per la progettazione di una struttura comune per i livelli, ho creato un'interfaccia 'Level' e
un'abstract class 'AbstractLevel'. In Level vengono dichiarati i metodi che ogni livello dovrà possedere, mentre in AbstractLevel vengono implemetati. I metodi che
però definiscono caratteristiche differenti per ogni round del livello, sono dichiarati abstract e dovranno essere implementati nelle classi dei livelli. I tre livelli
dunque, 'FirstLevel','SecondLevel' e 'ThirdLevel', dovranno estendere la classe astratta AbstractLevel.
Level e AbstractLevel sono state create fin da subito, proprio per evitare di bloccare l'avanzamento dello sviluppo complessivo del progetto.
Inizialmente sono stati creati e implementati i metodi che avrebbero svolto le azioni principali, mentre successivamente a man mano che il progetto progrediva
sono stati aggiunti metodi e variabili che si sono dimostrati necessari.\\
Ogni livello è composto da tre round. Per quanto riguarda la realizzazione del primo livello, questi 3 round sono generati tramite delle costanti, che indicano
il numero di blocchi normali e blocchi sorpresa, da passare come argomento a 'RoundEasy'. RoundEasy definisce come questi blocchi debbano essere posizionati
nella schermata di gioco.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{images/Levels.png}
    \caption{Schema UML dell'organizzazione dei livelli.}
\end{figure}
\noindent
\textbf{Controlli sul Round}\\
Il decremento della vita all'interno del round di gioco e il passaggio all'eventuale round successivo sono
condizionati dai controlli fatti nella classe GameOver (del model). All'interno di questa classe sono presenti due metodi che restituiscono al Model
un valore booleano, che indicano se il player, tramite il controllo del pad, ha mancato la pallina oppure se il round è terminato.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/GameOver.png}
    \caption{Schema UML della classe GameOver.}
\end{figure}
\noindent
\textbf{View di Pausa, Game Over e Vittoria}\\
La parte grafica del progetto prevede l'alternarsi di JPanels (che rappresentano menù inziale, menù di pausa, gameover, vittoria, classifica)
con la game view vera e propria.
Per la realizzazione della parte grafica di mia responsabilità (menù di pausa, game-over, vittoria), ho creato una classe astratta 'AbstractView'
che definsce delle impostazioni generali a cui fanno riferimento le classi che la estendono.
Queste caratteristiche prevedono uno sfondo nero, un titolo, e tre pulsanti. Due di questi pulsanti, menuBtn e quitBtn,
sono già definiti all'interno di AbstractView poichè sono in comune con tutti e tre i pannelli da visualizzare.
Il terzo pulsante viene impostato in AbstractView (a livello di posizionamento) ma definito nelle classi che estendono poichè questo pulsante e la
relativa azione che svolge cambia in base a quale panel l'untente si interfaccia nell'avanzamento del gioco.
L'istanza UIController permette ai pannelli di poter svolgere azioni come cambiare view (da tutti e tre i panels è possibile tramite il pulsante
mentuBtn andare alla schermata iniziale di gioco).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/AbstractView.png}
    \caption{Schema UML dell'implementazione della View di Pausa, Game Over e Vittoria.}
\end{figure}
\pagebreak
\subsection{Desiderio Edoardo}
Dal momento in cui si è formato il gruppo il mio primo obbiettivo è stato quello preoccuparmi di creare una buona impostazione,
in particolare grazie al colloquio con il professor Pianini ho potuto chiarire al gruppo maniera definitiva come fosse meglio
lavorare sul repository del progetto e come doveva funzionare il pattern dell'applicazione da noi scelto.
In oltre, ho studiato come funzionano i file json di configurazione di vscode in maniera da fornire una configurazione user friendly
a tutti i miei colleghi per un' esperienza "out of the box" dell' IDE come la configurazione di un debugger meno invasivo rispetto quello di  default.
Ho riservato una buona attenzione a questa configurazione per limitare al massimo lo stress causato dalla poca intuittività di alcune
automattizzazioni ed essere sereni e tranquilli.\\
\textbf{UIController, la scelta di averlo.}\\
ho ritenuto vantaggioso avere un controller dedicato per la vista  che comunicasse
con il controller principale dell' applicazione.

Pagando con una maggiore ripetizione dei metodi "messaggeri" che si occupano semplicemente di trasportare informazioni
dall' applicazione alla sua vista si ottiene una maggiore manutentibilità e scalabilità dell'applicazione.
Di fatto si è verificato che modifice come:
\begin{itemize}
    \item modifica alle classi delle view
    \item aggiunta metodi o relativa modifica
    \item aggiunta di intere view
\end{itemize}
si sono rilevate poco costose sia in termini logici, guardando l'interfaccia UIController è lampante come muoversi,
che in termini pratici, per aggiungere una nuova vista basta aggiungere la sua dichiarazione e il metodo che la invochi.
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{images/UiControllerDesing.png}
    \caption{proiezione UML della comunicazione fra il controller principale e le viste con UIController}
\end{figure}
\textbf{UIController, l'implementazione.}\\





\chapter{Sviluppo}
\section{Testing automatizzato}
\section{Metodologia di lavoro}
Per lavorare
a questo progetto abbiamo cercato di strutturare il lavoro seguendo queste macro domande:
\subsection{Qual'è la missione del progetto e con quali risorse si intende perseguirla?}
La missione del progetto è ampiamente descritta nei paragrafi precedenti.
Le risorse da noi scelte in fase di pianificazione e progettazione sono varie tra cui:
\begin{itemize}
    \item materiale didattico fornito dai professori
    \item plugin gradle
    \item versione di java 17
    \item git e github\footnote{\url{github.com}}
    \item strumenti di pianificazione, comunicazione e in generale multimediali forniti dall'account aziendale (unibo).
\end{itemize}

\subsection{Come verrà condotto il progetto?}
Si può riassumere la conduzione del progetto con un'organigramma orizzontale.
Ognuno ha piena responsabilità dei compiti che ci si è auto affidato al tempo di decisione e assegnazione delle task.
Questo implica il fatto che l'auto organizzazione di ogni singolo componente è fondamentale per la buona riuscita del progetto.
Ovviamente in caso di difficoltà il gruppo stimolerà il singolo a una soluzione senza però intaccarne la creatività.
\subsection{Come ne verrà controllato l'avanzamento?}
\subsubsection{Organizzazione DVCS}
Nelle varie risorse scelte sono indicati git e github, git è un software DVCS presentato e spiegato a lezione mentre github.com è un servizio
hub di repository.
La produzione è organizzata su più branch.
\\Il branch principale (master nel nostro caso) raccoglie tutto il codice di progetto approvato da tutti, su github è settata una policy
di sicurezza affinchè sia obbligatorio aprire una pull request per poter eseguire il merging del codice.
Il branch develop raccoglie la linea di sviluppo in fase di pre-relies in cui è ammissibile trovare eventuali bug o errori di desing.
\\Ogni elemento del teamWork, ad ogni step evolutivo, si occupa di creare un branch locale che non è necessario venga pubblicato poichè finito
il lavoro si occuperà di eseguire il merging  in develop.
\subsubsection{Ciclo di vita del progetto}
Ogni pull request (develop - master) verrà eseguita quando il codice develop soddisfa i requisiti che l'applicazione deve avere rispetto
all'obbiettivo incrementale che ci siamo posti.
In linea di massima la nostra scelta è di procedere a piccoli passi fino alla finalizzazione del progetto.
\section{Note di sviluppo}
\chapter{Commenti finali}
\section{Autovalutazione e lavori futuri}

\appendix
\section{Guida utente}



\end{document}
